//@ sourceMappingURL=app.map
// Generated by CoffeeScript 1.6.0
(function() {
  process.env['WEB_API_HOST'] = '172.17.0.1' // real-time.config.env
  process.env['WEB_HOST'] = '172.17.0.1'
  process.env['WEB_URL'] = 'http://172.17.0.1:10001/api/v1/web/guest/sharelatex/web'
  process.env['DOOCUMENT_UPDATER_URL'] = 'http://172.17.0.1:10001/api/v1/web/guest/sharelatex/document-updater'
  process.env["SHAREALTEX_CONFIG"] = __dirname + '/settings.coffee';

  var CookieParser, DocumentUpdaterController, DrainManager, HealthCheckManager, Metrics, RedisStore, Router, SessionSockets, Settings, WebsocketLoadBalancer, app, async, clusterClient, cookieParser, drainAndShutdown, express, healthCheck, host, io, logger, port, publishJob, pubsubClient, rclient, redis, runPubSubTraffic, server, session, sessionRedisClient, sessionSockets, sessionStore, shutdownCleanly, shutdownDrainTimeWindow, signal, _, _i, _len, _ref, _ref1, _ref2;

  Metrics = require("metrics-sharelatex");

  Settings = require("settings-sharelatex");

  Metrics.initialize(Settings.appName || "real-time");

  async = require("async");

  _ = require("underscore");

  logger = require("logger-sharelatex");

  logger.initialize("real-time");

  Metrics.event_loop.monitor(logger);

  express = require("express");

  session = require("express-session");

  redis = require("redis-sharelatex");

  if (((_ref = Settings.sentry) != null ? _ref.dsn : void 0) != null) {
    logger.initializeErrorReporting(Settings.sentry.dsn);
  }

  sessionRedisClient = redis.createClient(Settings.redis.websessions);

  RedisStore = require('connect-redis')(session);

  SessionSockets = require('session.socket.io');

  CookieParser = require("cookie-parser");

  DrainManager = require("./app/js/DrainManager");

  HealthCheckManager = require("./app/js/HealthCheckManager");

  require("./socket.io.patch.js");

  app = express();

  server = require('http').createServer(app);

  io = require('socket.io').listen(server);

  sessionStore = new RedisStore({
    client: sessionRedisClient
  });

  cookieParser = CookieParser(Settings.security.sessionSecret);

  sessionSockets = new SessionSockets(io, sessionStore, cookieParser, Settings.cookieName);

  Metrics.injectMetricsRoute(app);

  app.use(Metrics.http.monitor(logger));

  io.configure(function() {
    io.enable('browser client minification');
    io.enable('browser client etag');
    io.set('match origin protocol', true);
    io.set('transports', ['websocket', 'flashsocket', 'htmlfile', 'xhr-polling', 'jsonp-polling']);
    return io.set('log level', 1);
  });

  app.get("/", function(req, res, next) {
    return res.send("real-time-sharelatex is alive");
  });

  app.get("/status", function(req, res, next) {
    if (Settings.shutDownInProgress) {
      return res.send(503);
    } else {
      return res.send("real-time-sharelatex is alive");
    }
  });

  app.get("/debug/events", function(req, res, next) {
    var _ref1;
    Settings.debugEvents = parseInt((_ref1 = req.query) != null ? _ref1.count : void 0, 10) || 20;
    logger.log({
      count: Settings.debugEvents
    }, "starting debug mode");
    return res.send("debug mode will log next " + Settings.debugEvents + " events");
  });

  rclient = require("redis-sharelatex").createClient(Settings.redis.realtime);

  healthCheck = function(req, res, next) {
    return rclient.healthCheck(function(error) {
      var status;
      if (error != null) {
        logger.err({
          err: error
        }, "failed redis health check");
        return res.sendStatus(500);
      } else if (HealthCheckManager.isFailing()) {
        status = HealthCheckManager.status();
        logger.err({
          pubSubErrors: status
        }, "failed pubsub health check");
        return res.sendStatus(500);
      } else {
        return res.sendStatus(200);
      }
    });
  };

  app.get("/health_check", healthCheck);

  app.get("/health_check/redis", healthCheck);

  Router = require("./app/js/Router");

  Router.configure(app, io, sessionSockets);

  WebsocketLoadBalancer = require("./app/js/WebsocketLoadBalancer");

  WebsocketLoadBalancer.listenForEditorEvents(io);

  DocumentUpdaterController = require("./app/js/DocumentUpdaterController");

  DocumentUpdaterController.listenForUpdatesFromDocumentUpdater(io);

  port = Settings.internal.realTime.port;

  host = Settings.internal.realTime.host;

  server.listen(port, host, function(error) {
    if (error != null) {
      throw error;
    }
    return logger.info("realtime starting up, listening on " + host + ":" + port);
  });

  Error.stackTraceLimit = 10;

  shutdownCleanly = function(signal) {
    var connectedClients, _ref1;
    connectedClients = (_ref1 = io.sockets.clients()) != null ? _ref1.length : void 0;
    if (connectedClients === 0) {
      logger.warn("no clients connected, exiting");
      return process.exit();
    } else {
      logger.warn({
        connectedClients: connectedClients
      }, "clients still connected, not shutting down yet");
      return setTimeout(function() {
        return shutdownCleanly(signal);
      }, 30 * 1000);
    }
  };

  drainAndShutdown = function(signal) {
    if (Settings.shutDownInProgress) {
      logger.warn({
        signal: signal
      }, "shutdown already in progress, ignoring signal");
    } else {
      Settings.shutDownInProgress = true;
      logger.warn({
        signal: signal
      }, "received interrupt, starting drain over " + shutdownDrainTimeWindow + " mins");
      DrainManager.startDrainTimeWindow(io, shutdownDrainTimeWindow);
      return shutdownCleanly(signal);
    }
  };

  Settings.shutDownInProgress = false;

  if (Settings.shutdownDrainTimeWindow != null) {
    shutdownDrainTimeWindow = parseInt(Settings.shutdownDrainTimeWindow, 10);
    logger.log({
      shutdownDrainTimeWindow: shutdownDrainTimeWindow
    }, "shutdownDrainTimeWindow enabled");
    _ref1 = ['SIGINT', 'SIGHUP', 'SIGQUIT', 'SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGABRT'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      signal = _ref1[_i];
      process.on(signal, drainAndShutdown);
    }
    if ((_ref2 = Settings.errors) != null ? _ref2.catchUncaughtErrors : void 0) {
      process.removeAllListeners('uncaughtException');
      process.on('uncaughtException', function(error) {
        var _ref3;
        if (['EPIPE', 'ECONNRESET'].includes(error.code)) {
          Metrics.inc('disconnected_write', 1, {
            status: error.code
          });
          return logger.warn({
            err: error
          }, 'attempted to write to disconnected client');
        }
        logger.error({
          err: error
        }, 'uncaught exception');
        if ((_ref3 = Settings.errors) != null ? _ref3.shutdownOnUncaughtError : void 0) {
          return drainAndShutdown('SIGABRT');
        }
      });
    }
  }

  if (Settings.continualPubsubTraffic) {
    console.log("continualPubsubTraffic enabled");
    pubsubClient = redis.createClient(Settings.redis.pubsub);
    clusterClient = redis.createClient(Settings.redis.websessions);
    publishJob = function(channel, callback) {
      var checker, json;
      checker = new HealthCheckManager(channel);
      logger.debug({
        channel: channel
      }, "sending pub to keep connection alive");
      json = JSON.stringify({
        health_check: true,
        key: checker.id,
        date: new Date().toString()
      });
      return pubsubClient.publish(channel, json, function(err) {
        if (err != null) {
          logger.err({
            err: err,
            channel: channel
          }, "error publishing pubsub traffic to redis");
        }
        return clusterClient.publish("cluster-continual-traffic", {
          keep: "alive"
        }, callback);
      });
    };
    runPubSubTraffic = function() {
      return async.map(["applied-ops", "editor-events"], publishJob, function(err) {
        return setTimeout(runPubSubTraffic, 1000 * 20);
      });
    };
    runPubSubTraffic();
  }

}).call(this);
