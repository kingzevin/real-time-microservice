//@ sourceMappingURL=WebsocketLoadBalancer.map
// Generated by CoffeeScript 1.6.0
(function() {
  var Async, ChannelManager, ConnectedUsersManager, EventLogger, HealthCheckManager, RESTRICTED_USER_MESSAGE_TYPE_PASS_LIST, RedisClientManager, RoomManager, SafeJsonParse, Settings, Utils, WebsocketLoadBalancer, logger,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Settings = require('settings-sharelatex');

  logger = require('logger-sharelatex');

  RedisClientManager = require("./RedisClientManager");

  SafeJsonParse = require("./SafeJsonParse");

  EventLogger = require("./EventLogger");

  HealthCheckManager = require("./HealthCheckManager");

  RoomManager = require("./RoomManager");

  ChannelManager = require("./ChannelManager");

  ConnectedUsersManager = require("./ConnectedUsersManager");

  Utils = require('./Utils');

  Async = require('async');

  RESTRICTED_USER_MESSAGE_TYPE_PASS_LIST = ['connectionAccepted', 'otUpdateApplied', 'otUpdateError', 'joinDoc', 'reciveNewDoc', 'reciveNewFile', 'reciveNewFolder', 'removeEntity'];

  module.exports = WebsocketLoadBalancer = {
    rclientPubList: RedisClientManager.createClientList(Settings.redis.pubsub),
    rclientSubList: RedisClientManager.createClientList(Settings.redis.pubsub),
    emitToRoom: function() {
      var data, message, payload, rclientPub, room_id, _i, _len, _ref, _results;
      room_id = arguments[0], message = arguments[1], payload = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (room_id == null) {
        logger.warn({
          message: message,
          payload: payload
        }, "no room_id provided, ignoring emitToRoom");
        return;
      }
      data = JSON.stringify({
        room_id: room_id,
        message: message,
        payload: payload
      });
      logger.log({
        room_id: room_id,
        message: message,
        payload: payload,
        length: data.length
      }, "emitting to room");
      _ref = this.rclientPubList;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rclientPub = _ref[_i];
        _results.push(ChannelManager.publish(rclientPub, "editor-events", room_id, data));
      }
      return _results;
    },
    emitToAll: function() {
      var message, payload;
      message = arguments[0], payload = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.emitToRoom.apply(this, ["all", message].concat(__slice.call(payload)));
    },
    listenForEditorEvents: function(io) {
      var rclientSub, _i, _len, _ref;
      logger.log({
        rclients: this.rclientPubList.length
      }, "publishing editor events");
      logger.log({
        rclients: this.rclientSubList.length
      }, "listening for editor events");
      _ref = this.rclientSubList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rclientSub = _ref[_i];
        rclientSub.subscribe("editor-events");
        rclientSub.on("message", function(channel, message) {
          if (Settings.debugEvents > 0) {
            EventLogger.debugEvent(channel, message);
          }
          return WebsocketLoadBalancer._processEditorEvent(io, channel, message);
        });
      }
      return this.handleRoomUpdates(this.rclientSubList);
    },
    handleRoomUpdates: function(rclientSubList) {
      var roomEvents;
      roomEvents = RoomManager.eventSource();
      roomEvents.on('project-active', function(project_id) {
        var rclient, subscribePromises;
        subscribePromises = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = rclientSubList.length; _i < _len; _i++) {
            rclient = rclientSubList[_i];
            _results.push(ChannelManager.subscribe(rclient, "editor-events", project_id));
          }
          return _results;
        })();
        return RoomManager.emitOnCompletion(subscribePromises, "project-subscribed-" + project_id);
      });
      return roomEvents.on('project-empty', function(project_id) {
        var rclient, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = rclientSubList.length; _i < _len; _i++) {
          rclient = rclientSubList[_i];
          _results.push(ChannelManager.unsubscribe(rclient, "editor-events", project_id));
        }
        return _results;
      });
    },
    _processEditorEvent: function(io, channel, message) {
      return SafeJsonParse.parse(message, function(error, message) {
        var client, clientList, seen, status, _i, _len, _ref, _results;
        if (error != null) {
          logger.error({
            err: error,
            channel: channel
          }, "error parsing JSON");
          return;
        }
        if (message.room_id === "all") {
          try {
            return (_ref = io.sockets).emit.apply(_ref, [message.message].concat(__slice.call(message.payload)));
          } catch (error) {
            return logger.warn({
              message: message,
              error: error
            }, "error sending message to clients");
          }
        } else if (message.message === 'clientTracking.refresh' && (message.room_id != null)) {
          clientList = io.sockets.clients(message.room_id);
          logger.log({
            channel: channel,
            message: message.message,
            room_id: message.room_id,
            message_id: message._id,
            socketIoClients: (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = clientList.length; _i < _len; _i++) {
                client = clientList[_i];
                _results.push(client.id);
              }
              return _results;
            })()
          }, "refreshing client list");
          _results = [];
          for (_i = 0, _len = clientList.length; _i < _len; _i++) {
            client = clientList[_i];
            _results.push(ConnectedUsersManager.refreshClient(message.room_id, client.id));
          }
          return _results;
        } else if (message.room_id != null) {
          if ((message._id != null) && Settings.checkEventOrder) {
            status = EventLogger.checkEventOrder("editor-events", message._id, message);
            if (status === "duplicate") {
              return;
            }
          }
          clientList = io.sockets.clients(message.room_id);
          if (clientList.length === 0) {
            return;
          }
          logger.log({
            channel: channel,
            message: message.message,
            room_id: message.room_id,
            message_id: message._id,
            socketIoClients: (function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = clientList.length; _j < _len1; _j++) {
                client = clientList[_j];
                _results1.push(client.id);
              }
              return _results1;
            })()
          }, "distributing event to clients");
          seen = {};
          return Async.eachLimit(clientList, 2, function(client, cb) {
            return Utils.getClientAttributes(client, ['is_restricted_user'], function(err, _arg) {
              var is_restricted_user, _ref1;
              is_restricted_user = _arg.is_restricted_user;
              if (err != null) {
                return cb(err);
              }
              if (client.disconnected) {
                logger.warn({
                  channel: channel,
                  client: client.id
                }, "skipping emit, client not connected");
                return cb();
              }
              if (!seen[client.id]) {
                seen[client.id] = true;
                if (!(is_restricted_user && (_ref1 = message.message, __indexOf.call(RESTRICTED_USER_MESSAGE_TYPE_PASS_LIST, _ref1) < 0))) {
                  try {
                    client.emit.apply(client, [message.message].concat(__slice.call(message.payload)));
                  } catch (error) {
                    console.log({
                      message: message,
                      client_id: client.id,
                      error: error
                    }, "error sending message to client");
                  }
                }
              }
              return cb();
            });
          }, function(err) {
            if (err != null) {
              return logger.err({
                err: err,
                message: message
              }, "Error sending message to clients");
            }
          });
        } else if (message.health_check != null) {
          logger.debug({
            message: message
          }, "got health check message in editor events channel");
          return HealthCheckManager.check(channel, message.key);
        }
      });
    }
  };

}).call(this);
