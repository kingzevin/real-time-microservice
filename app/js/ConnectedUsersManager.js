//@ sourceMappingURL=ConnectedUsersManager.map
// Generated by CoffeeScript 1.6.0
(function() {
  var FOUR_DAYS_IN_S, Keys, ONE_DAY_IN_S, ONE_HOUR_IN_S, REFRESH_TIMEOUT_IN_S, Settings, USER_TIMEOUT_IN_S, async, logger, rclient, redis;

  async = require("async");

  Settings = require('settings-sharelatex');

  logger = require("logger-sharelatex");

  redis = require("redis-sharelatex");

  rclient = redis.createClient(Settings.redis.realtime);

  Keys = Settings.redis.realtime.key_schema;

  ONE_HOUR_IN_S = 60 * 60;

  ONE_DAY_IN_S = ONE_HOUR_IN_S * 24;

  FOUR_DAYS_IN_S = ONE_DAY_IN_S * 4;

  USER_TIMEOUT_IN_S = ONE_HOUR_IN_S / 4;

  REFRESH_TIMEOUT_IN_S = 10;

  module.exports = {
    updateUserPosition: function(project_id, client_id, user, cursorData, callback) {
      var multi;
      if (callback == null) {
        callback = function(err) {};
      }
      logger.log({
        project_id: project_id,
        client_id: client_id
      }, "marking user as joined or connected");
      multi = rclient.multi();
      multi.sadd(Keys.clientsInProject({
        project_id: project_id
      }), client_id);
      multi.expire(Keys.clientsInProject({
        project_id: project_id
      }), FOUR_DAYS_IN_S);
      multi.hset(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), "last_updated_at", Date.now());
      multi.hset(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), "user_id", user._id);
      multi.hset(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), "first_name", user.first_name || "");
      multi.hset(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), "last_name", user.last_name || "");
      multi.hset(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), "email", user.email || "");
      if (cursorData != null) {
        multi.hset(Keys.connectedUser({
          project_id: project_id,
          client_id: client_id
        }), "cursorData", JSON.stringify(cursorData));
      }
      multi.expire(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), USER_TIMEOUT_IN_S);
      return multi.exec(function(err) {
        if (err != null) {
          logger.err({
            err: err,
            project_id: project_id,
            client_id: client_id
          }, "problem marking user as connected");
        }
        return callback(err);
      });
    },
    refreshClient: function(project_id, client_id, callback) {
      var multi;
      if (callback == null) {
        callback = function(err) {};
      }
      logger.log({
        project_id: project_id,
        client_id: client_id
      }, "refreshing connected client");
      multi = rclient.multi();
      multi.hset(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), "last_updated_at", Date.now());
      multi.expire(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), USER_TIMEOUT_IN_S);
      return multi.exec(function(err) {
        if (err != null) {
          logger.err({
            err: err,
            project_id: project_id,
            client_id: client_id
          }, "problem refreshing connected client");
        }
        return callback(err);
      });
    },
    markUserAsDisconnected: function(project_id, client_id, callback) {
      var multi;
      logger.log({
        project_id: project_id,
        client_id: client_id
      }, "marking user as disconnected");
      multi = rclient.multi();
      multi.srem(Keys.clientsInProject({
        project_id: project_id
      }), client_id);
      multi.expire(Keys.clientsInProject({
        project_id: project_id
      }), FOUR_DAYS_IN_S);
      multi.del(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }));
      return multi.exec(callback);
    },
    _getConnectedUser: function(project_id, client_id, callback) {
      return rclient.hgetall(Keys.connectedUser({
        project_id: project_id,
        client_id: client_id
      }), function(err, result) {
        if ((result == null) || Object.keys(result).length === 0 || !result.user_id) {
          result = {
            connected: false,
            client_id: client_id
          };
        } else {
          result.connected = true;
          result.client_id = client_id;
          result.client_age = (Date.now() - parseInt(result.last_updated_at, 10)) / 1000;
          if (result.cursorData != null) {
            try {
              result.cursorData = JSON.parse(result.cursorData);
            } catch (e) {
              logger.error({
                err: e,
                project_id: project_id,
                client_id: client_id,
                cursorData: result.cursorData
              }, "error parsing cursorData JSON");
              return callback(e);
            }
          }
        }
        return callback(err, result);
      });
    },
    getConnectedUsers: function(project_id, callback) {
      var self;
      self = this;
      return rclient.smembers(Keys.clientsInProject({
        project_id: project_id
      }), function(err, results) {
        var jobs;
        if (err != null) {
          return callback(err);
        }
        jobs = results.map(function(client_id) {
          return function(cb) {
            return self._getConnectedUser(project_id, client_id, cb);
          };
        });
        return async.series(jobs, function(err, users) {
          if (users == null) {
            users = [];
          }
          if (err != null) {
            return callback(err);
          }
          users = users.filter(function(user) {
            return (user != null ? user.connected : void 0) && (user != null ? user.client_age : void 0) < REFRESH_TIMEOUT_IN_S;
          });
          return callback(null, users);
        });
      });
    }
  };

}).call(this);
