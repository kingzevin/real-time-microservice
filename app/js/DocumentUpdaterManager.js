//@ sourceMappingURL=DocumentUpdaterManager.map
// Generated by CoffeeScript 1.6.0
(function() {
  var DocumentUpdaterManager, Keys, logger, metrics, rclient, request, settings, _;

  request = require("request");

  _ = require("underscore");

  logger = require("logger-sharelatex");

  settings = require("settings-sharelatex");

  metrics = require("metrics-sharelatex");

  rclient = require("redis-sharelatex").createClient(settings.redis.documentupdater);

  Keys = settings.redis.documentupdater.key_schema;

  module.exports = DocumentUpdaterManager = {
    getDocument: function(project_id, doc_id, fromVersion, callback) {
      var timer, url;
      if (callback == null) {
        callback = function(error, exists, doclines, version) {};
      }
      timer = new metrics.Timer("get-document");
      url = "" + settings.apis.documentupdater.url + "/project/" + project_id + "/doc/" + doc_id + "?fromVersion=" + fromVersion;
      logger.log({
        project_id: project_id,
        doc_id: doc_id,
        fromVersion: fromVersion
      }, "getting doc from document updater");
      return request.get(url, function(err, res, body) {
        var _ref, _ref1;
        timer.done();
        if (err != null) {
          logger.error({
            err: err,
            url: url,
            project_id: project_id,
            doc_id: doc_id
          }, "error getting doc from doc updater");
          return callback(err);
        }
        if ((200 <= (_ref = res.statusCode) && _ref < 300)) {
          logger.log({
            project_id: project_id,
            doc_id: doc_id
          }, "got doc from document document updater");
          try {
            body = JSON.parse(body);
          } catch (error) {
            return callback(error);
          }
          return callback(null, body != null ? body.lines : void 0, body != null ? body.version : void 0, body != null ? body.ranges : void 0, body != null ? body.ops : void 0);
        } else if ((_ref1 = res.statusCode) === 404 || _ref1 === 422) {
          err = new Error("doc updater could not load requested ops");
          err.statusCode = res.statusCode;
          logger.warn({
            err: err,
            project_id: project_id,
            doc_id: doc_id,
            url: url,
            fromVersion: fromVersion
          }, "doc updater could not load requested ops");
          return callback(err);
        } else {
          err = new Error("doc updater returned a non-success status code: " + res.statusCode);
          err.statusCode = res.statusCode;
          logger.error({
            err: err,
            project_id: project_id,
            doc_id: doc_id,
            url: url
          }, "doc updater returned a non-success status code: " + res.statusCode);
          return callback(err);
        }
      });
    },
    flushProjectToMongoAndDelete: function(project_id, callback) {
      var timer, url;
      if (callback == null) {
        callback = function() {};
      }
      logger.log({
        project_id: project_id
      }, "deleting project from document updater");
      timer = new metrics.Timer("delete.mongo.project");
      url = ("" + settings.apis.documentupdater.url + "/project/" + project_id + "?background=true") + (settings.shutDownInProgress ? "&shutdown=true" : "");
      return request.del(url, function(err, res, body) {
        var _ref;
        timer.done();
        if (err != null) {
          logger.error({
            err: err,
            project_id: project_id
          }, "error deleting project from document updater");
          return callback(err);
        } else if ((200 <= (_ref = res.statusCode) && _ref < 300)) {
          logger.log({
            project_id: project_id
          }, "deleted project from document updater");
          return callback(null);
        } else {
          err = new Error("document updater returned a failure status code: " + res.statusCode);
          err.statusCode = res.statusCode;
          logger.error({
            err: err,
            project_id: project_id
          }, "document updater returned failure status code: " + res.statusCode);
          return callback(err);
        }
      });
    },
    queueChange: function(project_id, doc_id, change, callback) {
      var allowedKeys, doc_key, error, jsonChange;
      if (callback == null) {
        callback = function() {};
      }
      allowedKeys = ['doc', 'op', 'v', 'dupIfSource', 'meta', 'lastV', 'hash'];
      change = _.pick(change, allowedKeys);
      jsonChange = JSON.stringify(change);
      if (jsonChange.indexOf("\u0000") !== -1) {
        error = new Error("null bytes found in op");
        logger.error({
          err: error,
          project_id: project_id,
          doc_id: doc_id,
          jsonChange: jsonChange
        }, error.message);
        return callback(error);
      }
      doc_key = "" + project_id + ":" + doc_id;
      return rclient.rpush(Keys.pendingUpdates({
        doc_id: doc_id
      }), jsonChange, function(error) {
        if (error != null) {
          return callback(error);
        }
        return rclient.rpush("pending-updates-list", doc_key, function(error) {
          // zevin
          if (error == null) {
            const request = require('request'); // real-time.background.publisher
            url = "" + settings.apis.documentupdater.url + '/RedisUpdated'
            request.get(url)
          }
          return callback(error)
        });
      });
    }
  };

}).call(this);
