//@ sourceMappingURL=Router.map
// Generated by CoffeeScript 1.6.0
(function() {
  var HttpApiController, HttpController, Router, Utils, WebsocketController, basicAuth, bodyParser, httpAuth, logger, metrics, settings,
    __slice = [].slice;

  metrics = require("metrics-sharelatex");

  logger = require("logger-sharelatex");

  settings = require("settings-sharelatex");

  WebsocketController = require("./WebsocketController");

  HttpController = require("./HttpController");

  HttpApiController = require("./HttpApiController");

  Utils = require("./Utils");

  bodyParser = require("body-parser");

  basicAuth = require('basic-auth-connect');

  httpAuth = basicAuth(function(user, pass) {
    var isValid;
    isValid = user === settings.internal.realTime.user && pass === settings.internal.realTime.pass;
    if (!isValid) {
      logger.err({
        user: user,
        pass: pass
      }, "invalid login details");
    }
    return isValid;
  });

  module.exports = Router = {
    _handleError: function(callback, error, client, method, extraAttrs) {
      if (callback == null) {
        callback = (function(error) {});
      }
      if (extraAttrs == null) {
        extraAttrs = {};
      }
      return Utils.getClientAttributes(client, ["project_id", "doc_id", "user_id"], function(_, attrs) {
        var key, value, _ref;
        for (key in extraAttrs) {
          value = extraAttrs[key];
          attrs[key] = value;
        }
        attrs.client_id = client.id;
        attrs.err = error;
        if (error.name === "CodedError") {
          logger.warn(attrs, error.message, {
            code: error.code
          });
          return callback({
            message: error.message,
            code: error.code
          });
        }
        if ((_ref = error.message) === "not authorized" || _ref === "doc updater could not load requested ops" || _ref === "no project_id found on client") {
          logger.warn(attrs, error.message);
          return callback({
            message: error.message
          });
        } else {
          logger.error(attrs, "server side error in " + method);
          return callback({
            message: "Something went wrong in real-time service"
          });
        }
      });
    },
    configure: function(app, io, session) {
      app.set("io", io);
      app.get("/clients", HttpController.getConnectedClients);
      app.get("/clients/:client_id", HttpController.getConnectedClient);
      app.post("/project/:project_id/message/:message", httpAuth, bodyParser.json({
        limit: "5mb"
      }), HttpApiController.sendMessage);
      app.post("/drain", httpAuth, HttpApiController.startDrain);
      return session.on('connection', function(error, client, session) {
        var user, _ref, _ref1, _ref2;
        if (client != null) {
          client.on("error", function(err) {
            logger.err({
              clientErr: err
            }, "socket.io client error");
            if (client.connected) {
              try {
                client.emit("reconnectGracefully");
                return client.disconnect();
              } catch (error) {
                return logger.warn({
                  error: error,
                  cause: err,
                  client_id: client.id
                }, "error telling client to reconnect after error");
              }
            }
          });
        }
        if (settings.shutDownInProgress) {
          try {
            client.emit("connectionRejected", {
              message: "retry"
            });
            client.disconnect();
          } catch (error) {
            logger.warn({
              error: error,
              client_id: client.id,
              message: "retry"
            }, "error rejecting client connection");
          }
          return;
        }
        if ((client != null) && (error != null ? (_ref = error.message) != null ? _ref.match(/could not look up session by key/) : void 0 : void 0)) {
          logger.warn({
            err: error,
            client: client != null,
            session: session != null
          }, "invalid session");
          try {
            client.emit("connectionRejected", {
              message: "invalid session"
            });
            client.disconnect();
          } catch (error) {
            logger.warn({
              error: error,
              client_id: client.id,
              message: "invalid session"
            }, "error rejecting client connection");
          }
          return;
        }
        if (error != null) {
          logger.err({
            err: error,
            client: client != null,
            session: session != null
          }, "error when client connected");
          try {
            if (client != null) {
              client.emit("connectionRejected", {
                message: "error"
              });
            }
            if (client != null) {
              client.disconnect();
            }
          } catch (error) {
            logger.warn({
              error: error,
              client_id: client != null ? client.id : void 0,
              message: "error"
            }, "error rejecting client connection");
          }
          return;
        }
        try {
          client.emit("connectionAccepted");
        } catch (error) {
          logger.warn({
            error: error,
            client_id: client.id
          }, "error accepting client connection");
          return;
        }
        metrics.inc('socket-io.connection');
        metrics.gauge('socket-io.clients', (_ref1 = io.sockets.clients()) != null ? _ref1.length : void 0);
        logger.log({
          session: session,
          client_id: client.id
        }, "client connected");
        if ((session != null ? (_ref2 = session.passport) != null ? _ref2.user : void 0 : void 0) != null) {
          user = session.passport.user;
        } else if ((session != null ? session.user : void 0) != null) {
          user = session.user;
        } else {
          user = {
            _id: "anonymous-user"
          };
        }
        client.on("joinProject", function(data, callback) {
          if (data == null) {
            data = {};
          }
          if (data.anonymousAccessToken) {
            user.anonymousAccessToken = data.anonymousAccessToken;
          }
          return WebsocketController.joinProject(client, user, data.project_id, function() {
            var args, err;
            err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (err != null) {
              return Router._handleError(callback, err, client, "joinProject", {
                project_id: data.project_id,
                user_id: user != null ? user.id : void 0
              });
            } else {
              return callback.apply(null, [null].concat(__slice.call(args)));
            }
          });
        });
        client.on("disconnect", function() {
          var _ref3;
          metrics.inc('socket-io.disconnect');
          metrics.gauge('socket-io.clients', ((_ref3 = io.sockets.clients()) != null ? _ref3.length : void 0) - 1);
          return WebsocketController.leaveProject(io, client, function(err) {
            if (err != null) {
              return Router._handleError(null, err, client, "leaveProject");
            }
          });
        });
        client.on("joinDoc", function(doc_id, fromVersion, options, callback) {
          if (typeof fromVersion === "function" && !options) {
            callback = fromVersion;
            fromVersion = -1;
            options = {};
          } else if (typeof fromVersion === "number" && typeof options === "function") {
            callback = options;
            options = {};
          } else if (typeof fromVersion === "object" && typeof options === "function") {
            callback = options;
            options = fromVersion;
            fromVersion = -1;
          } else if (typeof fromVersion === "number" && typeof options === "object") {

          } else {
            logger.error({
              "arguments": arguments
            }, "unexpected arguments");
            return typeof callback === "function" ? callback(new Error("unexpected arguments")) : void 0;
          }
          return WebsocketController.joinDoc(client, doc_id, fromVersion, options, function() {
            var args, err;
            err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (err != null) {
              return Router._handleError(callback, err, client, "joinDoc", {
                doc_id: doc_id,
                fromVersion: fromVersion
              });
            } else {
              return callback.apply(null, [null].concat(__slice.call(args)));
            }
          });
        });
        client.on("leaveDoc", function(doc_id, callback) {
          return WebsocketController.leaveDoc(client, doc_id, function() {
            var args, err;
            err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (err != null) {
              return Router._handleError(callback, err, client, "leaveDoc");
            } else {
              return callback.apply(null, [null].concat(__slice.call(args)));
            }
          });
        });
        client.on("clientTracking.getConnectedUsers", function(callback) {
          if (callback == null) {
            callback = function(error, users) {};
          }
          return WebsocketController.getConnectedUsers(client, function(err, users) {
            if (err != null) {
              return Router._handleError(callback, err, client, "clientTracking.getConnectedUsers");
            } else {
              return callback(null, users);
            }
          });
        });
        client.on("clientTracking.updatePosition", function(cursorData, callback) {
          if (callback == null) {
            callback = function(error) {};
          }
          return WebsocketController.updateClientPosition(client, cursorData, function(err) {
            if (err != null) {
              return Router._handleError(callback, err, client, "clientTracking.updatePosition");
            } else {
              return callback();
            }
          });
        });
        return client.on("applyOtUpdate", function(doc_id, update, callback) {
          if (callback == null) {
            callback = function(error) {};
          }
          return WebsocketController.applyOtUpdate(client, doc_id, update, function(err) {
            if (err != null) {
              return Router._handleError(callback, err, client, "applyOtUpdate", {
                doc_id: doc_id,
                update: update
              });
            } else {
              return callback();
            }
          });
        });
      });
    }
  };

}).call(this);
